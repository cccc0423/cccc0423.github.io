---
title: "é€±è¨˜ï¼ˆä¸ƒï¼‰"
subtitle: "è¶…æ²’æ•ˆç‡çš„å¦ä¸€é€±"
date: 2025-03-08
categories: [ "é€±è¨˜" ]
include-after-body: "../emphasis-point.html"
margin-header: |
  >  <ruby>
  >    é€±<rt>ã„“ã„¡</rt>è¨˜<rt>ã„ã„§Ë‹</rt>
  >  </ruby>
  >  <br>
  >  <div style="font-size: 0.8em">ç•¶é€±éš¨æ‰‹å¯«ä¸‹çš„æµæ°´å¸³ã€‚</div>
---

## ä¿®èª²

ä¸çŸ¥é“è¦å¯«ä»€éº¼ï¼Œä¾†å¯«ä¸Šèª²å­¸åˆ°ä»€éº¼å¥½äº†ã€‚åœ¨æ­¤ä¹‹å‰è£œè¿°ä¸€ä¸‹ä¸Šé€±çš„å­¸ç¿’ã€‚

### ä¸Šé€±

æ›¸æ³•èª²åˆ†åˆå­¸èˆ‡é€²éšå…©çµ„ã€‚é€™èˆ‡ç·´ç¿’çš„ææ–™å’Œè©•åˆ†æ¨™æº–æœ‰é—œã€‚é›–ç„¶æˆ‘å­¸äº†ä¸€é™£å­äº†ï¼Œä½†é‚„æ˜¯æ²’æŠŠæ¡è‡ªå·±èƒ½ç®—æ˜¯é€²éšçµ„ï¼Œæ‰€ä»¥é¸äº†åˆå­¸çµ„ã€‚æˆ‘ä¿®çš„é€™é–€èª²æ•™æ™ºæ°¸çš„çœŸæ›¸åƒå­—æ–‡ã€‚æ‰€è¬‚çœŸæ›¸ï¼Œå°±æ˜¯æ¥·æ›¸çš„æ„æ€ã€‚ç•¶ç„¶åœ¨é‚£å€‹æ™‚ä»£ï¼ˆéš‹æœï¼‰ï¼Œå› ç‚ºæ¥·æ›¸ä¼¼ä¹é‚„æ²’æœ‰ç™¼å±•å¾—é‚£éº¼æˆç†Ÿï¼ˆï¼Ÿï¼‰ï¼Œæ‰€ä»¥æ™ºæ°¸çš„æ¥·æ›¸ä¹Ÿå¸¶æœ‰ä¸€é»é»è¡Œæ›¸çš„ç­†æ„ã€‚ä¸Šé€±åˆå­¸çµ„å¾åŸºæœ¬ç­†ç•«é»ã€æ’‡é–‹å§‹ã€‚

è‡³æ–¼çµ±è¨ˆå­¸ç¿’ï¼Œä¸Šèª²é€²åº¦çœŸçš„å¾ˆå¿«ã€‚ä¸Šé€±è€å¸«æ•™äº† ESL çš„ç¬¬å››ç« ã€‚ç¬¬å››ç« çš„ä¸»é¡Œæ˜¯ç”¨æ–¼åˆ†é¡çš„ç·šæ€§æ–¹æ³•ã€‚æ‰€è¬‚ç·šæ€§æ–¹æ³•ï¼ŒæŒ‡çš„æ˜¯é‚£äº›åˆ¤åˆ¥å‡½æ•¸ $\delta_k(x)$ æˆ–å¾Œé©—æ©Ÿç‡ $P(G = k \mid X = x)$ æ¨¡å‹ï¼ˆåœ¨å–®èª¿è½‰æ›å¾Œï¼‰æ˜¯ç·šæ€§çš„æ–¹æ³•ã€‚

å…·é«”è€Œè¨€ï¼Œé€™ç« ç¯€æœ€ä¸»è¦ä»‹ç´¹ linear discriminant analysis (LDA) å’Œ logistic regressionï¼Œèˆ‡ä»–å€‘çš„ä¸€äº›è®Šå½¢ã€‚æœ‰è¶£çš„æ˜¯ LDA å’Œ logistic regression å…¶å¯¦å¯ä»¥å°å‡ºç­‰åƒ¹çš„åˆ¤åˆ¥æº–å‰‡ï¼Œå¯æ˜¯ LDA å»éœ€è¦å‡è¨­è³‡æ–™å¾å¸¸æ…‹åˆ†é…ä¸­æŠ½å‡ºã€‚é€™ä½¿ logistic regression åœ¨ç†è«–ä¸Šæ›´ç©©å¥ï¼Œè€Œç•¶è³‡æ–™çœŸçš„å¾å¸¸æ…‹åˆ†é…ç”Ÿæˆæ™‚ï¼ŒLDA çš„æ¼¸é€²æ•ˆç‡æ›´å¥½ã€‚å¦ä¸€ä»¶æœ‰è¶£çš„äº‹æƒ…æ˜¯ LDA èˆ‡ç·šæ€§è¿´æ­¸æœ‰ä¸€å€‹æ¯”è¼ƒæ·±çš„é€£çµï¼›èª²æœ¬ç¿’é¡Œ 4.2 è®“æˆ‘å€‘é€æ­¥æ¨å°ï¼Œåœ¨äºŒå…ƒåˆ†é¡å•é¡Œä¸­ï¼Œå¦‚æœå…©é¡åˆ¥çš„æ¨£æœ¬æ•¸ç›¸ç•¶ï¼Œé‚£ç·šæ€§è¿´æ­¸çš„æ±ºç­–é‚Šç•Œå…¶å¯¦å°±æ˜¯ LDA çš„æ±ºç­–é‚Šç•Œã€‚ä¸éæˆ‘é‚„æ²’æœ‰åƒé€èƒŒå¾Œçš„ç›´è§€æ„ç¾©ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œæœ€å¾Œé‚„æäº†ä¸€é»åŸºæ–¼ separating hyperplanes çš„åˆ†é¡æ–¹æ³•ï¼Œå¦‚ perceptron learning algorithmï¼Œç„¶å¾Œç‚º support vector machine (SVM) é‹ªè·¯ã€‚

### æœ¬é€±

é€™é€±æ›¸æ³•èª²è®“æˆ‘å€‘ç·´ç¿’æ©«ç•«ã€‚ä¸éï¼Œæˆ‘ç•¶ç„¶å·²ç¶“å¾ˆæœƒäº†ã€‚å°±é€™æ¨£æ²’ä»€éº¼å£“åŠ›åœ°åº¦éå…©ç¯€èª²ã€‚

é€™é€±çš„çµ±è¨ˆå­¸ç¿’æ•™ ESL ç¬¬äº”ç« çš„å‰åŠã€‚ç¬¬äº”ç« çš„å…§å®¹æ˜¯ basis expansions å’Œ regularizationã€‚æˆ‘å€‘é€™é€±å°±æ•™å„ç¨® splinesã€‚æˆ‘æœ‰æ„Ÿè¦ºè€å¸«å› ç‚ºæ„Ÿè¦ºè‡ªå·±ä¸Šå¤ªå¿«ï¼Œæ‰€ä»¥åˆ»æ„æ”¾æ…¢é€Ÿåº¦ã€‚è‡³æ–¼ï¼Œæœ‰ä»€éº¼æœ‰è¶£çš„æ±è¥¿å—ï¼Ÿæˆ‘è¦ºå¾—èª²æœ¬ç¿’é¡Œ 5.7ï¼Œèªª knots åœ¨è³‡æ–™é» $x_i$ ä¸Šçš„ natrual cubic splines å¯ä»¥æœ€å°åŒ–
$$
\operatorname{RSS}(f, \lambda)
= \sum_{i=1}^N \left( y_i - f(x_i) \right)^2 + \lambda \int f''(t)^2 \, dt
$$
é€™å€‹ç›®æ¨™å‡½æ•¸ï¼Œæ˜¯ä¸€ä»¶å¾ˆæœ‰è¶£çš„äº‹æƒ…ã€‚ä¸éè¬› smoothing splines çš„è¨ˆç®—æ™‚ä»‹ç´¹åˆ° B-splinesï¼Œæˆ‘çœŸçš„æ˜¯å°é€™éƒ¨åˆ†æ„Ÿè¦ºå¾ˆé™Œç”Ÿã€‚æœ‰æ™‚é–“æ‡‰è©²å¥½å¥½ç ”ç©¶ç ”ç©¶ğŸ˜…ã€‚

## ç ”ç©¶èˆ‡é–±è®€

åˆæ˜¯ç¢©è«–æ¯«ç„¡é€²å±•çš„ä¸€é€±ã€‚é‚„æ²’æ‹¿å®šä¸»æ„è¦åšä»€éº¼ã€‚ä¾†èªªä¸€ä¸‹æˆ‘åˆ°åº•æ˜¯å°ä»€éº¼æœ‰èˆˆè¶£ã€‚

æˆ‘æƒ³è¦åšå¥½çš„æ‡‰ç”¨å€‹é«”ã€‚æˆ‘ä¸èªçˆ²æˆ‘æœƒã€æˆ‘æœ‰èƒ½åŠ›æˆ–æˆ‘æƒ³æˆç‚ºä¸€å€‹ç´”ç²¹çš„ econometric theoristã€‚èˆ‡å…¶èªªæˆ‘å°è¨ˆé‡ç¶“æ¿Ÿå­¸æœ‰èˆˆè¶£ï¼Œæ›´è²¼åˆ‡çš„èªªæ³•æ˜¯ï¼Œæˆ‘åœ¨å¾äº‹ç¶“é©—ç ”ç©¶çš„éç¨‹ä¸­ï¼Œç”¢ç”Ÿä¸€äº›å›°æƒ‘ã€‚æˆ‘ç™¼ç¾å…¶ä¸­æœ‰äº›å›°æƒ‘æ›¾ç¶“è¢«ä¸€äº›äººï¼Œä¾‹å¦‚è¨ˆé‡ç¶“æ¿Ÿå­¸å®¶ã€å…¶ä»–ç§‘å­¸é ˜åŸŸçš„å­¸è€…æˆ–è€…ç§‘å­¸å“²å­¸å®¶è©¢å•ã€å˜—è©¦è§£ç­”éã€‚æˆ‘å¯¦åœ¨å¾ˆè‘—è¿·æ–¼é€™äº›æ ¹æœ¬çš„ç§‘å­¸æ–¹æ³•è«–å•é¡Œã€‚ä¸€å€‹æœ€ç°¡å–®ã€æœ€æ™®éçš„ç–‘å•æ˜¯ï¼Œä»€éº¼æ™‚å€™æˆ‘å€‘æœƒèªª $X$ å° $Y$ æœ‰å› æœé—œä¿‚ï¼Ÿï¼ˆé€™ä¸æ˜¯ä¸€å€‹ç°¡å–®çš„å•é¡Œï¼‰ã€‚ç„¶å¾Œæˆ‘å€‘é‚„å¯ä»¥é€€ä¸€æ­¥å•ï¼Œé€™å€‹å•é¡Œæ˜¯æœ‰æ„ç¾©çš„å—ï¼Ÿ

å›åˆ°æ­£é¡Œï¼Œå¦‚æœè¦åœ¨ç¶“æ¿Ÿç³»åšä¸€äº›ç›¸é—œçš„ç ”ç©¶ï¼Œæœ€ç›´æ¥åœ°å°±æ˜¯æˆ‘å»åšä¸€äº›è¨ˆé‡ç¶“æ¿Ÿå­¸çš„æ–¹æ³•ç ”ç©¶ã€‚ç¾åœ¨æˆ‘æœ‰ä¸€äº›æ„Ÿèˆˆè¶£çš„é—œéµå­—ï¼š

1. æˆ‘å° difference-in-differences (DiD) æ¯”è¼ƒç†Ÿæ‚‰ï¼Œé€™æ˜¯åšå¯¦è­‰ç ”ç©¶çš„ç¶“æ¿Ÿå­¸å®¶éå¸¸å¸¸ç”¨çš„ç ”ç©¶è¨­è¨ˆã€‚å•é¡Œåœ¨æ–¼ï¼ŒDiD çš„ papers çœŸçš„æ±—ç‰›å……æ£Ÿï¼Œæˆ‘ä¸çŸ¥é“æˆ‘æœ‰å¯èƒ½åšå‡ºä»€éº¼æ–°çš„è²¢ç»ã€‚

2. æˆ‘å° mediation analysis æœ‰èˆˆè¶£ä½†ä¸ç†Ÿæ‚‰ï¼Œé€™ä¸¦ä¸æ˜¯å¤§å¤šæ•¸ç¶“æ¿Ÿå­¸å®¶ç†Ÿæ‚‰çš„æ±è¥¿ï¼Œåšé€™å€‹çš„å¤§å¤šåœ¨æµè¡Œç—…å­¸ã€æ”¿æ²»å­¸ç­‰é ˜åŸŸã€‚æˆ‘è¦ºå¾—é€™å€‹é ˜åŸŸæœ‰å¾ˆå¤šæœ‰è¶£çš„å•é¡Œã€‚å…¶ä¸­ä¹‹ä¸€ï¼Œå°±æ˜¯æˆ‘å€‘èƒ½ä¸èƒ½æ”¾å¯¬ç¶“å…¸çš„ sequential ignorability å‡è¨­ã€‚æˆ‘æ›¾ç¶“åœ¨ JC çš„æ©Ÿå™¨å­¸ç¿’èª²çš„æœŸæœ«å ±å‘Šï¼Œå˜—è©¦æå‡ºä¸€å€‹åˆ©ç”¨ parallel trends å‡è¨­ä¾†è­˜åˆ¥ä¸€äº› mediation analysis åƒæ•¸çš„æƒ³æ³•ï¼ˆç„¶å¾Œç”¨ double ML çš„æ–¹å¼ä¼°è¨ˆï¼‰ã€‚é€™æ˜¯ä¸€å€‹ DiD è¨­è¨ˆçš„æ‡‰ç”¨ã€‚ä½†æ˜¯ï¼Œå¾Œä¾†æˆ‘ä¹Ÿæœ‰é»é›£ä¿¡æœæˆ‘ä¸‹çš„ parallel trends å‡è¨­çœŸçš„å¯èƒ½åœ¨ç¾å¯¦ä¸–ç•Œæˆç«‹ã€‚ä¸€å€‹æ½›åœ¨çš„æ–¹å‘æ˜¯å»ç ”ç©¶å®ƒçš„ empirical contentsï¼Œå¦‚æœ€è¿‘æœ‰æ–‡ç« åœ¨è¨è«–æ€æ¨£çš„ selection mechanism æœƒç”¢ç”Ÿ parallel trendsï¼Œä½†æˆ‘å°é€™æ–¹å‘å¾ˆæ‚²è§€ï¼Œæˆ‘æ„Ÿè¦ºæˆ‘æ²’æœ‰èƒ½åŠ›ï¼Œè€Œä¸”æ²’æœ‰å¥½çµæœã€‚å¦ä¸€å€‹æ–¹å‘æ˜¯å¾€ principal stratification çš„æ–¹å‘ç™¼å±•ï¼Œå¯æ˜¯é€™æ„Ÿè¦ºæœ€çµ‚åˆæœƒå¤ªåƒæŸç¯‡ JBES çš„æ–‡ç« ã€‚

3. æˆ‘å° treatment heterogeneity ä¹Ÿæœ‰èˆˆè¶£ã€‚é€™æ˜¯å¦ä¸€å€‹å¾ˆå†·é–€çš„ä¸»é¡Œã€‚å­¸éå› æœæ¨è«– 101 çš„äººéƒ½è½é effect heterogeneityï¼Œä½† treatment heterogeneity æ˜¯å¦ä¸€å€‹å•é¡Œã€‚åœ¨ Rubin causal model è£¡ï¼Œé€šå¸¸å‡è¨­ stable unit treatment value assumption (SUTVA)ã€‚é€™å€‹å‡è¨­å¯ä»¥åˆ†æˆå…©å€‹éƒ¨åˆ†ï¼Œç¬¬ä¸€æ˜¯æ²’æœ‰å¹²æ“¾ï¼ˆinterferenceï¼‰ï¼Œä¹Ÿå°±æ˜¯èªªï¼Œä»»ä½•äººçš„ treatment condition éƒ½ä¸æœƒå½±éŸ¿å…¶ä»–äººçš„ outcomeï¼›ç¬¬äºŒæ˜¯ treatment æ²’æœ‰å¤šå€‹ã€Œç‰ˆæœ¬ã€ï¼Œä¹Ÿå°±æ˜¯èªªï¼Œé‚£äº›è¢«åŠƒåˆ†æˆæœ‰åŒæ¨£çš„ treatment condition çš„äººï¼Œä»–å€‘çš„ treatment condition çœŸçš„æ˜¯ä¸€æ¨£çš„ã€‚ç¬¬äºŒå€‹éƒ¨åˆ†æ¯”è¼ƒå¾®å¦™ï¼Œç¶“æ¿Ÿå­¸çš„æ–‡ç»ä¹Ÿå¾ˆå°‘äººç ”ç©¶ï¼Œæ—¢æœ‰çš„è¨è«–å¤§éƒ¨åˆ†åœ¨æµè¡Œç—…å­¸çš„æ–‡ç»è£¡ã€‚æ‰€è¬‚æ²’æœ‰å¤šå€‹ç‰ˆæœ¬ï¼Œå…¶å¯¦æ˜¯è¦æ±‚ treatment æœ‰æ¸…æ¥šçš„å®šç¾©ã€‚ä»¥è¡€å£“ç‚ºä¾‹ï¼Œç ”ç©¶è€…å¯èƒ½æƒ³äº†è§£é™ä½è¡€å£“å°å¥åº·çš„æ•ˆæœï¼Œä½†æ˜¯é€™å€‹ treatment æœ‰å¾ˆå¤šç‰ˆæœ¬ï¼Œæ¯”å¦‚è—¥ç‰©æ²»ç™‚ã€æ‰‹è¡“æ²»ç™‚ã€é£²é£Ÿæ²»ç™‚ç­‰ç­‰ã€‚å¦‚æœæ”¾åœ¨ Heckman é‚£å¥—ã€Œæ€æƒ³å¯¦é©—ã€çš„æ¡†æ¶çš„è©±ï¼Œæ²’æœ‰å¤šå€‹ç‰ˆæœ¬çš„è¦æ±‚äº‹å¯¦ä¸Šä¹Ÿå¯ä»¥çœ‹æˆè¦æ±‚ç ”ç©¶è€…æ‰€è§€å¯Ÿåˆ°çš„å¯¦é©—çµ„å’Œå°ç…§çµ„ï¼ŒçœŸçš„èˆ‡ä»–å¿ƒç›®ä¸­çš„æ€æƒ³å¯¦é©—çš„åƒæ•¸æœ‰é—œã€‚é€™å€‹å•é¡Œåœ¨ç¶“æ¿Ÿå­¸ä¸­ä¼¼ä¹æ¯”è¼ƒå°‘è¢«è©³ç´°è¨è«–ã€‚æ¯”å¦‚ï¼Œæˆ‘å€‘ç¶“å¸¸æ¸¬é‡å©šå§»çš„æ•ˆæœã€ç”Ÿè‚²çš„æ•ˆæœï¼Œä½†æ˜¯é€™äº› treatment çš„å®šç¾©å…¶å¯¦æ˜¯å¾ˆæ¨¡ç³Šçš„ï¼Œå¾ˆé›£æƒ³åƒçœŸçš„æ»¿è¶³ SUTVAã€‚è€Œé€™äº›ç ”ç©¶è€…å¿ƒç›®ä¸­çš„æ€æƒ³å¯¦é©—æ˜¯ä»€éº¼ï¼Ÿè¦æ€éº¼æŠŠå•é¡Œå®šç¾©æ¸…æ¥šï¼Ÿ

## å…¶ä»–

é€±å››åƒäº†å€‹æœ‰é»è²´çš„æ™šé¤ã€‚ç¾åœ¨å·²ç¶“è¦ºå¾—è‡ªå·±å°åƒæ±è¥¿æ²’æœ‰å¤ªå¤§èˆˆè¶£äº†ğŸ˜…ã€‚ä¸¦ä¸”é«”æ‚Ÿåˆ°ç¯€åˆ¶æ‡‰è©²æ˜¯é‡è¦çš„ç¾å¾·ã€‚å¦å¤–ï¼Œæˆ‘é‚„æ˜¯è¦ºå¾—æˆ‘æ›´é©åˆä¸€äº›æ¯”è¼ƒæ¥åœ°æ°£çš„é£Ÿç‰©ï¼Œä¾‹å¦‚æ³°ç±³é¦™çš„æ²¹çˆ†è‰è¦ã€èšçš„åŒ—æµ·é“æ˜†å¸ƒæ¹¯æˆ–è€…é›™æœˆçš„è’œå¥½å¥½ç˜¦è‚‰æ¹¯ã€‚

### ç”¨ Claude 3.7 Sonnet å®Œæˆ Perceptron æ¼”ç®—æ³•çš„äº’å‹•å¼è¦–è¦ºåŒ–

ç¾åœ¨çš„ LLM çœŸçš„ä¸éŒ¯ç”¨ã€‚æˆ‘ç”¨å®ƒå¯«äº†ä¸€å€‹ perceptron æ¼”ç®—æ³•çš„äº’å‹•å¼è¦–è¦ºåŒ–ã€‚é€™å€‹è¦–è¦ºåŒ–æ˜¯åŸºæ–¼ SVG çš„ï¼Œæˆ‘åªæœ‰æ‰‹å‹•ä¿®æ”¹ä¸€äº›ç¾æ„Ÿçš„éƒ¨åˆ†ã€‚

Rosenblatt çš„ perceptron æ¼”ç®—æ³•æ˜¯ä¸€å€‹ç°¡å–®çš„äºŒå…ƒåˆ†é¡æ¼”ç®—æ³•ã€‚å®ƒçš„ç›®æ¨™æ˜¯æ‰¾åˆ°ä¸€å€‹ hyperplaneï¼Œä½¿å¾—æ­£é¡æ¨£æœ¬ï¼ˆæ¨™ç±¤ç‚º $+1$ çš„é‚£äº›ï¼‰åœ¨ hyperplane çš„ä¸€é‚Šï¼Œè² é¡æ¨£æœ¬ï¼ˆæ¨™ç±¤ç‚º $-1$ çš„é‚£äº›ï¼‰åœ¨ hyperplane çš„å¦ä¸€é‚Šã€‚é€™å€‹ hyperplane å¯ä»¥å¯«æˆ $\beta_1^\intercal x + \beta_0 = 0$ æˆ– $\beta^\intercal x^*$ï¼Œå…¶ä¸­ï¼Œ$\beta = (\beta_1, \beta_0)$ å¯ä»¥çœ‹æˆæ˜¯è©² hyperplane çš„æ³•å‘é‡ï¼Œ$x^* = (x, 1)$ æ˜¯æ¨£æœ¬çš„ç‰¹å¾µå‘é‡ã€‚

é‚£é€™å€‹æ¼”ç®—æ³•å¯¦éš›ä¸Šæ€éº¼æ‰¾åˆ°é‚£å€‹ hyperplane å‘¢ï¼Ÿå®ƒä½¿ç”¨ä¸€ç¨®éš¨æ©Ÿçš„æ¢¯åº¦ä¸‹é™æ³•ã€‚å…·é«”ä¾†èªªï¼Œå°æ–¼ä¸€å€‹è¢«èª¤åˆ†é¡çš„æ¨£æœ¬ $x_i^*$ï¼Œæˆ‘å€‘æ›´æ–° $\beta$ çš„è¦å‰‡æ˜¯ $\beta_{\text{new}} \leftarrow \beta_{\text{old}} + y_i z_i$ï¼Œå…¶ä¸­ $y_i$ æ˜¯æ¨£æœ¬çš„æ¨™ç±¤ï¼Œ$z_i = x_i^* / \| x_i^* \|$ æ˜¯æ¨£æœ¬çš„æ¨™æº–åŒ–å‘é‡ã€‚

ä»¥ä¸‹çš„è¦–è¦ºåŒ–å±•ç¤ºï¼Œå‡è¨­è©² $x_i^*$ çš„æ¨™ç±¤æ˜¯ $-1$ è€Œä½¿å¾— $\beta^\intercal x_i + \beta_0 > 0$ï¼Œé‚£éº¼æˆ‘å€‘å°±æ‡‰è©²æŠŠ $\beta$ å‘ $z_i$ çš„åæ–¹å‘ç§»å‹•ä¸€äº›ï¼Œä½¿å¾— hyperplane èƒ½å¤ æ­£ç¢ºåˆ†é¡é€™å€‹æ¨£æœ¬ã€‚

```{=html}
<div id="perceptron-container" style="max-width:900px;margin:0 auto;">
  <div style="width:100%;height:550px;position:relative;">
    <svg id="perceptron-svg" width="800" height="500" style="display:block;margin:0 auto;border:1px solid #ddd;background-color:#fff;"></svg>
  </div>

  <div style="text-align:center;margin-bottom:20px;">
    <button id="step-button" class="btn btn-primary">åŸ·è¡Œä¸€æ­¥</button>
    <button id="auto-button" class="btn btn-success">è‡ªå‹•é‹è¡Œ</button>
    <button id="reset-button" class="btn btn-danger">é‡ç½®</button>
  </div>

  <div class="callout callout-style-default callout-note callout-titled">
  <div class="callout-header d-flex align-content-center">
  <div class="callout-icon-container">
  <i class="callout-icon"></i>
  </div>
  <div class="callout-title-container flex-fill">
  ç•¶å‰ç‹€æ…‹
  </div>
  </div>
  <div class="callout-body-container callout-body">
  <ul>
    <li>è¿­ä»£æ¬¡æ•¸ï¼š<span id="iteration-count">0</span></li>
    <li><span class="math inline">\(\beta\)</span>ï¼š(<span id="beta-x">0.00</span>, <span id="beta-y">0.00</span>, <span id="beta-bias">0.00</span>)</li>
    <li id="selected-point-info" style="display:none;">
      <ul>
        <li>é¸ä¸­çš„é»ï¼š(<span id="point-x"></span>, <span id="point-y"></span>)ï¼›æ¨™ç±¤ï¼š<span id="point-label"></span></li>
        <li>æ¨™æº–åŒ–å‘é‡ <span class="math inline">\(z\)</span>ï¼š(<span id="z-x"></span>, <span id="z-y"></span>, <span id="z-bias"></span>)</li>
      </ul>
    </li>
  </ul>
  </div>
  </div>

  <div class="callout callout-style-default callout-tip callout-titled">
  <div class="callout-header d-flex align-content-center">
  <div class="callout-icon-container">
  <i class="callout-icon"></i>
  </div>
  <div class="callout-title-container flex-fill">
  æ¼”ç®—æ³•èªªæ˜
  </div>
  </div>
  <div class="callout-body-container callout-body">
  <ul>
    <li>ç´…è‰²å‘é‡ï¼š<span class="math inline">\(\beta\)</span> åƒæ•¸å‘é‡ï¼Œæ±ºå®šæ±ºç­–é‚Šç•Œï¼Œå‚ç›´æ–¼æ±ºç­–é‚Šç•Œ</li>
    <li>è—è‰²ç·šï¼šç•¶å‰æ±ºç­–é‚Šç•Œ</li>
    <li>ç¶ è‰²é»ï¼šæ­£é¡æ¨£æœ¬ï¼ˆ<span class="math inline">\(+1\)</span>ï¼‰</li>
    <li>ç´…è‰²é»ï¼šè² é¡æ¨£æœ¬ï¼ˆ<span class="math inline">\(-1\)</span>ï¼‰</li>
    <li>ç´«è‰²è™›ç·šï¼šæ¨™æº–åŒ–å‘é‡ <span class="math inline">\(z\)</span> </li>
    <li>æ›´æ–°è¦å‰‡ï¼š<span class="math inline">\(\beta_{\text{new}} \leftarrow \beta_{\text{old}} + y_i z_i\)</span>ï¼ˆå…¶ä¸­ <span class="math inline">\(y_i\)</span> æ˜¯é»çš„æ¨™ç±¤ï¼Œ<span class="math inline">\(z_i\)</span>  æ˜¯æ¨™æº–åŒ–å‘é‡ï¼‰</li>
    <li>è™›ç·šæ¡†ï¼šç•¶å‰è¢«èª¤åˆ†é¡çš„é»</li>
  </ul>
  </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // ç•«å¸ƒè¨­ç½® - å¢åŠ å°ºå¯¸
  const svg = document.getElementById('perceptron-svg');
  const width = parseFloat(svg.getAttribute('width'));
  const height = parseFloat(svg.getAttribute('height'));
  const margin = 40; // å¢åŠ é‚Šè·
  const centerX = width / 2;
  const centerY = height / 2;
  const scale = 70; // å¢åŠ åˆ»åº¦æ¯”ä¾‹
  
  // SVG å‘½åç©ºé–“
  const svgNS = "http://www.w3.org/2000/svg";
  
  // æ„ŸçŸ¥æ©Ÿç‹€æ…‹
  let beta = { x: 0, y: 0, bias: 0 };
  // ä¿®æ”¹æ•¸æ“šé»ï¼Œä½¿å®ƒå€‘æ›´åŠ åˆ†æ•£ï¼Œé¿å…é è¿‘æ±ºç­–é‚Šç•Œçš„æ¨¡ç³Šæƒ…æ³
  let points = [
    { id: 1, x: 2.5, y: 1.5, label: 1 },
    { id: 2, x: 1.5, y: 2.5, label: 1 },
    { id: 3, x: -0.5, y: 1.5, label: 1 },
    { id: 4, x: -2.5, y: -1.5, label: -1 },
    { id: 5, x: -1.5, y: -2.5, label: -1 },
    { id: 6, x: 1.5, y: -1.5, label: -1 }
  ];
  let selectedPoint = null;
  let iterations = 0;
  let autoRunTimer = null;
  
  // åº§æ¨™è½‰æ›å‡½æ•¸
  function toScreenX(x) {
    return centerX + x * scale;
  }
  
  function toScreenY(y) {
    return centerY - y * scale;
  }
  
  // æ¨™æº–åŒ–å‘é‡
  function normalize(vector) {
    const norm = Math.sqrt(vector.x * vector.x + vector.y * vector.y + 1);
    return {
      x: vector.x / norm,
      y: vector.y / norm,
      bias: 1 / norm
    };
  }
  
  // åˆ¤æ–·é»æ˜¯å¦è¢«éŒ¯èª¤åˆ†é¡ - å¢åŠ æ˜ç¢ºçš„é–¾å€¼
  function isMisclassified(point) {
    const normalizedPoint = normalize(point);
    const dotProduct = beta.x * normalizedPoint.x + beta.y * normalizedPoint.y + beta.bias * normalizedPoint.bias;
    
    // ä½¿ç”¨é–¾å€¼ï¼Œé¿å…éå¸¸æ¥è¿‘æ±ºç­–é‚Šç•Œçš„æƒ…æ³å¼•èµ·æ··æ·†
    const threshold = 0.01;
    
    if (point.label > 0) {
      return dotProduct < threshold; // æ­£é¡æ¨£æœ¬æ‡‰è©²æœ‰è¼ƒå¤§çš„æ­£å€¼
    } else {
      return dotProduct > -threshold; // è² é¡æ¨£æœ¬æ‡‰è©²æœ‰è¼ƒå¤§çš„è² å€¼
    }
  }
  
  // æ‰¾åˆ°ç¬¬ä¸€å€‹éŒ¯èª¤åˆ†é¡çš„é»
  function findMisclassifiedPoint() {
    return points.find(point => isMisclassified(point)) || null;
  }
  
  // åˆå§‹åŒ– SVG
  function initializeSVG() {
    // æ¸…ç©º SVG
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    
    // å®šç¾©ç®­é ­æ¨™è¨˜
    const defs = document.createElementNS(svgNS, "defs");
    const marker = document.createElementNS(svgNS, "marker");
    marker.setAttribute("id", "arrowhead");
    marker.setAttribute("markerWidth", "10");
    marker.setAttribute("markerHeight", "7");
    marker.setAttribute("refX", "9");
    marker.setAttribute("refY", "3.5");
    marker.setAttribute("orient", "auto");
    
    const polygon = document.createElementNS(svgNS, "polygon");
    polygon.setAttribute("points", "0 0, 10 3.5, 0 7");
    
    marker.appendChild(polygon);
    defs.appendChild(marker);
    svg.appendChild(defs);
    
    // ç¹ªè£½åæ¨™è»¸ - å¢åŠ ç²—ç´°
    const xAxis = document.createElementNS(svgNS, "line");
    xAxis.setAttribute("x1", margin);
    xAxis.setAttribute("x2", width - margin);
    xAxis.setAttribute("y1", centerY);
    xAxis.setAttribute("y2", centerY);
    xAxis.setAttribute("stroke", "black");
    xAxis.setAttribute("stroke-width", "1.5"); // å¢åŠ ç·šå¯¬
    svg.appendChild(xAxis);
    
    const yAxis = document.createElementNS(svgNS, "line");
    yAxis.setAttribute("x1", centerX);
    yAxis.setAttribute("x2", centerX);
    yAxis.setAttribute("y1", margin);
    yAxis.setAttribute("y2", height - margin);
    yAxis.setAttribute("stroke", "black");
    yAxis.setAttribute("stroke-width", "1.5"); // å¢åŠ ç·šå¯¬
    svg.appendChild(yAxis);
    
    // xè»¸æ¨™ç±¤
    const xLabel = document.createElementNS(svgNS, "text");
    xLabel.setAttribute("x", width - margin + 20);
    xLabel.setAttribute("y", centerY + 15);
    xLabel.setAttribute("font-size", "16");
    xLabel.textContent = "xâ‚";
    svg.appendChild(xLabel);
    
    // yè»¸æ¨™ç±¤
    const yLabel = document.createElementNS(svgNS, "text");
    yLabel.setAttribute("x", centerX - 15);
    yLabel.setAttribute("y", margin - 20);
    yLabel.setAttribute("font-size", "16");
    yLabel.textContent = "xâ‚‚";
    svg.appendChild(yLabel);
    
    // ç¹ªè£½åˆ»åº¦
    [-3, -2, -1, 1, 2, 3].forEach(val => {
      // Xè»¸åˆ»åº¦
      const xTick = document.createElementNS(svgNS, "line");
      xTick.setAttribute("x1", toScreenX(val));
      xTick.setAttribute("x2", toScreenX(val));
      xTick.setAttribute("y1", centerY - 5);
      xTick.setAttribute("y2", centerY + 5);
      xTick.setAttribute("stroke", "black");
      xTick.setAttribute("stroke-width", "1");
      svg.appendChild(xTick);
      
      const xText = document.createElementNS(svgNS, "text");
      xText.setAttribute("x", toScreenX(val));
      xText.setAttribute("y", centerY + 20);
      xText.setAttribute("text-anchor", "middle");
      xText.setAttribute("font-size", "12");
      xText.textContent = val;
      svg.appendChild(xText);
      
      // Yè»¸åˆ»åº¦
      const yTick = document.createElementNS(svgNS, "line");
      yTick.setAttribute("x1", centerX - 4);
      yTick.setAttribute("x2", centerX + 4);
      yTick.setAttribute("y1", toScreenY(val));
      yTick.setAttribute("y2", toScreenY(val));
      yTick.setAttribute("stroke", "black");
      yTick.setAttribute("stroke-width", "1");
      svg.appendChild(yTick);
      
      const yText = document.createElementNS(svgNS, "text");
      yText.setAttribute("x", centerX - 20);
      yText.setAttribute("y", toScreenY(val) + 5);
      yText.setAttribute("text-anchor", "middle");
      yText.setAttribute("font-size", "12");
      yText.textContent = val;
      svg.appendChild(yText);
    });
    
    // åŸé»æ¨™è¨˜
    const originText = document.createElementNS(svgNS, "text");
    originText.setAttribute("x", centerX - 20);
    originText.setAttribute("y", centerY + 20);
    originText.setAttribute("font-size", "12");
    originText.textContent = "O";
    svg.appendChild(originText);
  }
  
  // ç¹ªè£½æ±ºç­–é‚Šç•Œ
  function drawDecisionBoundary() {
    // ç§»é™¤èˆŠçš„æ±ºç­–é‚Šç•Œ
    const oldLine = svg.querySelector(".decision-boundary");
    if (oldLine) {
      svg.removeChild(oldLine);
    }
    
    if (beta.x === 0 && beta.y === 0) {
      return;
    }
    
    // ax + by + c = 0 å½¢å¼
    const a = beta.x;
    const b = beta.y;
    const c = beta.bias;
    
    // è¨ˆç®—èˆ‡ç•«å¸ƒé‚Šç•Œçš„äº¤é»
    let startX, startY, endX, endY;
    
    if (Math.abs(b) < 0.001) {
      // è¿‘ä¼¼å‚ç›´ç·š
      startX = -c / a;
      endX = startX;
      startY = -4;
      endY = 4;
    } else {
      // ä¸€èˆ¬æƒ…æ³
      startX = -4;
      startY = (-c - a * startX) / b;
      endX = 4;
      endY = (-c - a * endX) / b;
    }
    
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", toScreenX(startX));
    line.setAttribute("y1", toScreenY(startY));
    line.setAttribute("x2", toScreenX(endX));
    line.setAttribute("y2", toScreenY(endY));
    line.setAttribute("stroke", "blue");
    line.setAttribute("stroke-width", "2");
    line.setAttribute("class", "decision-boundary");
    svg.appendChild(line);
  }
  
  // ç¹ªè£½åƒæ•¸å‘é‡ beta
  function drawBetaVector() {
    // ç§»é™¤èˆŠçš„åƒæ•¸å‘é‡
    const oldVector = svg.querySelector(".beta-vector");
    if (oldVector) {
      svg.removeChild(oldVector);
    }
    
    if (beta.x === 0 && beta.y === 0) {
      return;
    }
    
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", centerX);
    line.setAttribute("y1", centerY);
    line.setAttribute("x2", toScreenX(beta.x));
    line.setAttribute("y2", toScreenY(beta.y));
    line.setAttribute("stroke", "red");
    line.setAttribute("stroke-width", "2");
    line.setAttribute("marker-end", "url(#arrowhead)");
    line.setAttribute("class", "beta-vector");
    svg.appendChild(line);
  }
  
  // ç¹ªè£½æ¨™æº–åŒ–å‘é‡ z
  function drawNormalizedVector() {
    // ç§»é™¤èˆŠçš„æ¨™æº–åŒ–å‘é‡
    const oldVector = svg.querySelector(".normalized-vector");
    if (oldVector) {
      svg.removeChild(oldVector);
    }
    
    if (!selectedPoint) {
      return;
    }
    
    const z = normalize(selectedPoint);
    const zx = z.x * scale * 0.5;
    const zy = z.y * scale * 0.5;
    
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", centerX);
    line.setAttribute("y1", centerY);
    line.setAttribute("x2", centerX + zx);
    line.setAttribute("y2", centerY - zy);
    line.setAttribute("stroke", "purple");
    line.setAttribute("stroke-width", "2");
    line.setAttribute("stroke-dasharray", "5,5");
    line.setAttribute("marker-end", "url(#arrowhead)");
    line.setAttribute("class", "normalized-vector");
    svg.appendChild(line);
  }
  
  // ç¹ªè£½æ•¸æ“šé» - ä¿®æ”¹ç‚ºæ›´æ¸…æ™°åœ°é¡¯ç¤ºèª¤åˆ†é¡é»
  function drawPoints() {
    // ç§»é™¤èˆŠçš„é»
    const oldPoints = svg.querySelectorAll(".data-point");
    oldPoints.forEach(point => {
      svg.removeChild(point);
    });
    
    points.forEach(point => {
      const isSelected = selectedPoint && selectedPoint.id === point.id;
      const fillColor = point.label > 0 ? "#4CAF50" : "#F44336";
      const isMisclassed = isMisclassified(point);
      
      const circle = document.createElementNS(svgNS, "circle");
      circle.setAttribute("cx", toScreenX(point.x));
      circle.setAttribute("cy", toScreenY(point.y));
      circle.setAttribute("r", isSelected ? 12 : 10); // å¢åŠ é»çš„å¤§å°
      circle.setAttribute("fill", fillColor);
      
      // å¼·èª¿èª¤åˆ†é¡çš„é»
      if (isMisclassed) {
        circle.setAttribute("opacity", 1);
        circle.setAttribute("stroke", "black");
        circle.setAttribute("stroke-width", 2);
        circle.setAttribute("stroke-dasharray", "2,2"); // æ·»åŠ è™›ç·šé‚Šæ¡†
      } else {
        circle.setAttribute("opacity", 0.8);
        circle.setAttribute("stroke", isSelected ? "black" : "none");
        circle.setAttribute("stroke-width", isSelected ? 2 : 0);
      }
      
      circle.setAttribute("class", "data-point");
      svg.appendChild(circle);
      
      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", toScreenX(point.x));
      text.setAttribute("y", toScreenY(point.y) - 15);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", "13"); // å¢åŠ å­—é«”å¤§å°
      text.setAttribute("font-weight", "bold"); // åŠ ç²—
      text.setAttribute("class", "data-point");
      text.textContent = `(${point.x}, ${point.y})`;
      svg.appendChild(text);
    });
  }
  
  // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
  function updateStatusDisplay() {
    document.getElementById("iteration-count").textContent = iterations;
    document.getElementById("beta-x").textContent = beta.x.toFixed(2);
    document.getElementById("beta-y").textContent = beta.y.toFixed(2);
    document.getElementById("beta-bias").textContent = beta.bias.toFixed(2);
    
    const selectedPointInfo = document.getElementById("selected-point-info");
    
    if (selectedPoint) {
      const z = normalize(selectedPoint);
      
      document.getElementById("point-x").textContent = selectedPoint.x;
      document.getElementById("point-y").textContent = selectedPoint.y;
      document.getElementById("point-label").textContent = selectedPoint.label;
      document.getElementById("z-x").textContent = z.x.toFixed(2);
      document.getElementById("z-y").textContent = z.y.toFixed(2);
      document.getElementById("z-bias").textContent = z.bias.toFixed(2);
      
      selectedPointInfo.style.display = "block";
    } else {
      selectedPointInfo.style.display = "none";
    }
    
    // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
    const stepButton = document.getElementById("step-button");
    const autoButton = document.getElementById("auto-button");
    
    const misclassifiedPoint = findMisclassifiedPoint();
    stepButton.disabled = !misclassifiedPoint;
    autoButton.disabled = !misclassifiedPoint;
    
    if (!misclassifiedPoint && autoRunTimer) {
      clearInterval(autoRunTimer);
      autoRunTimer = null;
      autoButton.textContent = "è‡ªå‹•é‹è¡Œ";
    }
  }
  
  // é‡ç¹ªæ•´å€‹è¦–è¦ºåŒ–
  function redraw() {
    drawDecisionBoundary();
    drawBetaVector();
    drawNormalizedVector();
    drawPoints();
    updateStatusDisplay();
  }
  
  // åŸ·è¡Œä¸€æ­¥æ„ŸçŸ¥æ©Ÿæ›´æ–°
  function runStep() {
    const misclassifiedPoint = findMisclassifiedPoint();
    
    if (misclassifiedPoint) {
      selectedPoint = misclassifiedPoint;
      
      // æ¨™æº–åŒ–é»
      const z = normalize(misclassifiedPoint);
      
      // æ›´æ–° beta
      beta.x = beta.x + misclassifiedPoint.label * z.x;
      beta.y = beta.y + misclassifiedPoint.label * z.y;
      beta.bias = beta.bias + misclassifiedPoint.label * z.bias;
      
      iterations++;
      
      redraw();
      return true;
    } else {
      selectedPoint = null;
      redraw();
      return false;
    }
  }
  
  // é‡ç½®æ„ŸçŸ¥æ©Ÿ
  function reset() {
    beta = { x: 0, y: 0, bias: 0 };
    selectedPoint = null;
    iterations = 0;
    
    if (autoRunTimer) {
      clearInterval(autoRunTimer);
      autoRunTimer = null;
      document.getElementById("auto-button").textContent = "è‡ªå‹•é‹è¡Œ";
    }
    
    redraw();
  }
  
  // äº‹ä»¶ç›£è½å™¨
  document.getElementById("step-button").addEventListener("click", function() {
    runStep();
  });
  
  document.getElementById("auto-button").addEventListener("click", function() {
    if (autoRunTimer) {
      clearInterval(autoRunTimer);
      autoRunTimer = null;
      this.textContent = "è‡ªå‹•é‹è¡Œ";
    } else {
      this.textContent = "æš«åœ";
      autoRunTimer = setInterval(function() {
        const hasMore = runStep();
        if (!hasMore) {
          clearInterval(autoRunTimer);
          autoRunTimer = null;
          document.getElementById("auto-button").textContent = "è‡ªå‹•é‹è¡Œ";
        }
      }, 1000);
    }
  });
  
  document.getElementById("reset-button").addEventListener("click", reset);
  
  // åˆå§‹åŒ–
  initializeSVG();
  redraw();
});
</script>
```
