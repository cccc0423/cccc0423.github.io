<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-01-25">

<title>小學生筆記 - 週記（一）</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../images/icon.jpeg" rel="icon" type="image/jpeg">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">小學生筆記</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">關於</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#搬家" id="toc-搬家" class="nav-link active" data-scroll-target="#搬家">搬家</a></li>
  <li><a href="#閱讀" id="toc-閱讀" class="nav-link" data-scroll-target="#閱讀">閱讀</a>
  <ul class="collapse">
  <li><a href="#什麼是科學" id="toc-什麼是科學" class="nav-link" data-scroll-target="#什麼是科學">什麼是科學？</a></li>
  <li><a href="#科學推論" id="toc-科學推論" class="nav-link" data-scroll-target="#科學推論">科學推論</a></li>
  <li><a href="#科學解釋" id="toc-科學解釋" class="nav-link" data-scroll-target="#科學解釋">科學解釋</a></li>
  </ul></li>
  <li><a href="#同學會" id="toc-同學會" class="nav-link" data-scroll-target="#同學會">同學會</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">週記（一）</h1>
<p class="subtitle lead">農曆年前的最後一週</p>
  <div class="quarto-categories">
    <div class="quarto-category">週記</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 25, 2025</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="搬家" class="level2">
<h2 class="anchored" data-anchor-id="搬家">搬家</h2>
<p>這週最重要的事情莫過於搬家。</p>
<p>我在公館的租屋處如<a href="https://www.google.com/search?q=%E9%AB%98%E5%98%89%E7%91%9C+%E6%88%BF%E9%96%93">高嘉瑜的房間</a>一般雜亂。上週五被室友兼房東催促收拾。這件事確實是我應該做的，但是我卻一直拖延。他說要是不整理乾淨，租約到 3 月底就不再續約。我回覆他我會盡快整理。我一方面覺得羞恥，一方面覺得罪惡，但是又覺得他態度太差。不知道是不是我的誤會，我常常覺得因為我與他沒有私交，要是房子出現什麼他不滿意的地方，他通常會認為是我造成的，而不是另一個室友造成的（但是經常是另一個室友造成的，例如衣服沒收什麼的）。這件事情像是導火線。因為這個地點和這個房間都太不宜居，我一直覺得我應該要搬家，但是又覺得搬家很麻煩，而且我也不知道要搬到哪裡。這次終於下定決心要辦家。</p>
<p>按捺不住各種負面情緒，當晚很難入睡，一直忍不住滑手機，瀏覽各個臉書社團與 591 平臺上的招租。當下記了一些，私訊了其中一個房東。隔天早上起來看到房東回覆，要我打電話給他。我打了，約了時間，下午去看房。房東一開始接到電話好像還以為我是女生。他說他們的房子是限男，我還跟他說我是男生（可能因為我當下聲調比較高）。房東年紀 70 歲，話蠻多的，蠻主動跟我介紹一些有的沒的；穿著屬於得體老人，他的羽絨外套、長褲和皮鞋都感覺做工不錯。他說前房客是機械系的學生，從大學到碩班和他租了很多年，但要去工作了。我跟他說我大概就租一年，他問我怎麼不讀博班，我說可以的話想出國讀，可能去美國。他說他弟弟也在華盛頓特區讀過法律，以前是政府的公務員，後來也在大學教課（上網查一下發現他弟弟感覺蠻有名的😓）。總之，新住處的事情很快就搞定了，之後會住在科技大樓附近。</p>
<p>在新住處的事情搞定後，接下來我努力把舊住處搬空並清理乾淨。扛著大包小包的垃圾與回收物，步行反覆來回於舊住處與清潔隊之間（大約 1 公里）真的很累。除了一些真的毫無利用價值的垃圾，我也丟掉很多還算能用的東西。。並且，我也一邊把東西搬到新住處。</p>
<p>最棘手的問題是怎麼處理舊住處的租約。週二晚上我和他說我已經搬空並清潔完畢，如果可以的話我就歸還鑰匙。因為算是我想要提早解約，所以押金我就不取回了。他已讀。我週四早上忍不住和他說，如果沒問題的話，我隔天會去歸還鑰匙。他回他不在臺北。於是這件事大概要再拖延到二月。</p>
<p>我從 2022 年 4 月正式搬入舊住處。原先住在 BOT 宿舍的雙人房，因為很受不了室友的生活習慣，決定要搬到外面。當時犯的最大錯誤就是租在舊住處。租給我的對象是舊住處的其中一個室友，也就是前文所稱的「室友兼房東」，他似乎是臺科大的畢業生，據聞他已經租在這裡 12 年了。真正的房東把整層公寓租給他，然後他將多餘的房間出租給其他人。他並不是職業房東，所以我們當時沒有簽下白紙黑字的合約。現在我要搬走，我蠻擔心自己的權益會受損。</p>
</section>
<section id="閱讀" class="level2">
<h2 class="anchored" data-anchor-id="閱讀">閱讀<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2>
<p>這週讀了 <em>Philosophy of Science: A Very Short Introduction</em>。我第一次讀這系列（A Very Short Introduction, VSI）的書，它們由牛津大學出版社出版，每一本書都簡潔地介紹一個主題，是很棒的通識讀本。這本書的內容包括科學的定義、科學推論、科學解釋、科學革命、實在論與反實在論與對科學的批評等等。雖然大部分都是我已經知道的知識，但是作者用簡短的文字將這些知識點串連起來，還是讓我更清楚地認識科學哲學的基本概念。以下摘要與評論其中一些我覺得比較有趣的主題：什麼是科學？什麼是科學推論？什麼是科學解釋？</p>
<section id="什麼是科學" class="level3">
<h3 class="anchored" data-anchor-id="什麼是科學">什麼是科學？</h3>
<p>什麼是科學？二十世紀赫赫有名的科學哲學家 Karl Popper 認為科學最重要的特徵就是科學理論得要是可以被否證的（falsifiable）。所謂「可否證的」，即是指科學理論必須要有可能被實驗或觀察所推翻的預測。Popper 認為不可否證的理論不配被稱作科學，僅僅只是偽科學。</p>
<p>Popper 以佛洛依德的心理學和馬克思的歷史唯物主義為例，主張這兩者都是不可否證的理論，因此不是科學；無論病人出現怎樣的行為，信奉佛洛伊德的精神分析學家總是可以找到一種佛洛依德式的解釋，相似地，就算工業社會沒有從資本主義過渡到社會主義，馬克思主義者也總是可以找到一種符合馬克思理論的解釋。</p>
<p>Popper 認為愛因斯坦的廣義相對論即是一個鮮明的對照，其預測光線會受到太陽的重力場影響而彎曲，滿足可否證性的標準。而這個預測也在 1919 年的日食實驗中被證實。因此，愛因斯坦的理論是科學，而佛洛伊德和馬克思的理論則不是。</p>
<p>但是許多科學哲學家認為 Popper 的可否證性標準有點過於簡單了。Popper 指控精神分析學家和馬克思主義者在遇到與他們的理論相牴觸的證據時，他們會想辦法去找一個解釋，而不是放棄他們的理論。但是，這種行為在科學界也是普遍存在的。以牛頓的重力理論為例，它成功地預測了許多行星運動的軌跡，但是天王星的運動卻與牛頓的理論預測不符。John Adams 與 Urbain Leverrier 並沒有放棄牛頓的理論，而是提出了一個假設，即天王星的運動是由於另一顆還未被觀測到的行星的重力影響。他們並根據牛頓的理論<a href="https://zh.wikipedia.org/zh-tw/%E6%B5%B7%E7%8E%8B%E6%98%9F#%E8%A7%82%E6%B5%8B%E4%B8%8E%E7%99%BC%E7%8F%BE">預測了那顆尚未被發現的行星的質量與位置</a>。他們的預測幾乎與後來發現的海王星吻合。大家通常不會說 Adams 與 Leverrier 的行為是不科學的，但是他們做的事情就像是 Popper 對於精神分析學家與馬克思主義者的批評一樣——他們在遇到證據與他們的理論相牴觸時，他們並沒有放棄他們的理論，而是想辦法去找一個解釋。此外，<a href="https://zh.wikipedia.org/zh-tw/%E5%B9%BF%E4%B9%89%E7%9B%B8%E5%AF%B9%E8%AE%BA%E7%9A%84%E5%AE%9E%E9%AA%8C%E9%AA%8C%E8%AF%81#%E6%B0%B4%E6%98%9F%E8%BB%8C%E9%81%93%E8%BF%91%E6%97%A5%E9%BB%9E%E7%9A%84%E9%80%B2%E5%8B%95">水星在近日點的運動</a>也與牛頓的理論預測不符，但是科學家並沒有放棄牛頓的理論，他們起初想要如法炮製天王星的成功案例，提出了一個假設，即水星的運動是由於另一顆還未被觀測到的行星的重力影響。但是他們並沒有找到這顆行星，而是等到愛因斯坦提出廣義相對論，其預測的數值完全符合觀測結果。綜合這些例子，我們可以看到科學家在遇到證據與他們的理論相牴觸時，他們並不會立刻放棄他們的理論，這種行為在科學界是普遍存在的，因此 Popper 的可否證性標準可能不是一個很好的科學標準。</p>
<p>所以我們真的有辦法找到科學的一些共通的特徵嗎？就像維根斯坦的家族相似性那樣，許多東西被稱為遊戲，它們具備某些相似的特徵，但我們無法找到定義特徵來界定遊戲。科學也許就是這樣。</p>
</section>
<section id="科學推論" class="level3">
<h3 class="anchored" data-anchor-id="科學推論">科學推論</h3>
<p>科學家透過科學推論得出結論？但什麼是科學推論？</p>
<p>邏輯學家區分出兩種推論：演繹（deductive）推論與歸納（inductive）推論。演繹推論是從一些前提（premises）推出一個結論（conclusion），而當前提是真的時，結論也必定是真的。以著名的例子來說：</p>
<ol type="1">
<li><p>所有人都會死。</p></li>
<li><p>蘇格拉底是人。</p></li>
<li><p>所以，蘇格拉底會死。</p></li>
</ol>
<p>前提 1 與 2 是真的，所以結論 3 也必定是真的。這樣的推論即是演繹推論。但是並非所有推論都是演繹的。例如：</p>
<ol type="1">
<li><p>前 5 個雞蛋都是好的。</p></li>
<li><p>整盒雞蛋的有效日期都是一樣的。</p></li>
<li><p>所以，第 6 個雞蛋也是好的。</p></li>
</ol>
<p>這樣的推論並非演繹的，因為前提 1 與 2 都成立，邏輯上也並不隱含結論 3。這樣的推論即是歸納推論。在歸納推論中，我們通常從一些我們已經見過的事實推斷出一個我們還沒有見過的事實。</p>
<p>雖然演繹推論比起歸納推論更安全，但科學家也經常使用歸納推論。舉例來說，遺傳學家告訴我們唐氏症患者的第 21 對染色體有三條，而正常人只有兩條。但是這並不是因為遺傳學家看過所有的唐氏症患者的染色體，而得出這個結論的。他們只是看過一些唐氏症患者的染色體，然後推斷出所有唐氏症患者的染色體都是這樣的。這就是一個歸納推論。</p>
<p>雖然歸納推論在科學裡很常見，但 Karl Popper 卻認為科學家不應該使用歸納推論，而只使用演繹推論。他的論點如下，雖然科學理論或假說不可能被有限的資料所證明（proved），但是卻可以被否證或推翻。例如，我們可以通過觀察一個黑天鵝來推翻「所有天鵝都是白色」這個假說。但是，我們無法通過觀察一個白天鵝來證明這個假說。但問題是，科學家的目標並不只是想要推翻理論，還想要確定哪些理論是正確的。為了達到這個目標，科學家必須使用歸納推論。</p>
<p>但是，休謨稱使用歸納推論無法被合理的證成。注意到我們使用歸納推論時，我們似乎假定了自然的一致性（uniformity of nature）。例如，我們看到太陽每天都從東方升起，我們就假定明天太陽也會從東方升起。但是，我們無法證明自然的一致性。我們可以很輕易地想像一個自然不一致的世界。那麼，自然的一致性可以用經驗推論出來嗎？答案是否定的，因為這陷入了循環論證；我們不能因為自然經常是一致的，就認為自然總是一致的。因此，休謨認為，人相信歸納法並非因為它是合理的，而是因為動物本能使然。</p>
<p>此外還有一種推論，如以下作者舉出的範例：</p>
<ol type="1">
<li><p>儲藏室裡頭的起司不見了，留下一點碎屑。</p></li>
<li><p>昨晚儲藏室裡似乎傳出了抓取東西的聲音。</p></li>
<li><p>所以，起司被老鼠吃掉了。</p></li>
</ol>
<p>顯然這不是演繹推論。它稱為推論到最佳解釋（inference to the best explanation），也有人稱之為溯因推理。這種推論的基本思想是，我們應該選擇那個能夠最好解釋我們觀察到的現象的解釋。問題在於，哪些假說是最好的解釋？常見的標準是，一個好的解釋應該是簡單的。考慮以上的例子。我們可以考慮一個對立的假說，即起司是被女傭吃掉的，而他留下一些碎屑讓它看起來像是老鼠的傑作，而昨晚儲藏室的聲音其實是來自燒開水時水壺過熱發出的聲音。但是，我們通常會選擇老鼠這個解釋，因為女傭假說需要更多的假設而更複雜。不過，下一個問題是，為什麼我們會認為簡單的解釋是好的解釋？這個問題並沒有一個很好的答案。</p>
<p>作者最後談到因果推論與機率。以後應該會有很多機會寫到，暫且不提。</p>
</section>
<section id="科學解釋" class="level3">
<h3 class="anchored" data-anchor-id="科學解釋">科學解釋</h3>
<p>科學家嘗試解釋世界。但是什麼是科學解釋？當代的討論主要從 Carl Hempel 的覆蓋律模型（covering law model）或稱為演繹—律則模型（deductive-nomological model）開始。Hempel 作為一個邏輯實證主義者，他試圖從形式的角度刻劃科學解釋的結構。這個模型的基本思想是，科學解釋由兩部分組成：一是解釋項（explanans），即解釋的前提；二是被解釋項（explanandum），即解釋的現象。解釋項由普遍的律則（general law）與具體的事實或初始條件（initial conditions）組成，而解釋項必須在邏輯上推出被解釋項。</p>
<p>但是覆蓋律模型有一些著名的問題。<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 首先是對稱性的問題。假設我們想要解釋為何旗杆的影子長度是 <span class="math inline">\(20\)</span> 公尺。一個可能的解釋是，</p>
<blockquote class="blockquote">
<p>因為旗杆的高度是 <span class="math inline">\(15\)</span> 公尺，而太陽的仰角是 <span class="math inline">\(37^\circ\)</span>，所以，根據三角函數，影子的長度應該是 <span class="math inline">\(20\)</span> 公尺。</p>
</blockquote>
<p>這個解釋是合理的，也符合覆蓋律模型。但是，如果我們想要解釋為何旗杆的高度是 <span class="math inline">\(15\)</span> 公尺，我們也可以說，</p>
<blockquote class="blockquote">
<p>因為旗杆的影子長度是 <span class="math inline">\(20\)</span> 公尺，而太陽的仰角是 <span class="math inline">\(37^\circ\)</span>，所以，根據三角函數，旗杆的高度應該是 <span class="math inline">\(15\)</span> 公尺。</p>
</blockquote>
<p>這個解釋也是合理的，也符合覆蓋律模型。但是我們通常認為前者是一個好的解釋，而後者不是。關鍵在於我們經常期望解釋項與被解釋項的關係是不對稱的。覆蓋律模型無法捕捉這種不對稱性。另一個問題來自於無關緊要的解釋項。比如說，如果我們問醫生，「為什麼那個男人沒有懷孕？」而醫生回答說，</p>
<blockquote class="blockquote">
<p>因為他定期服用避孕藥數年，而定期服用避孕藥的人不會懷孕，因此那個男人不會成爲孕婦。</p>
</blockquote>
<p>就算醫生說的是真的，那個男人真的定期服用避孕藥，但我們不會認為這是一個好的解釋。正確的解釋應該是，「因為他是男人。」重點在於，好的解釋應該包含對於被解釋項的發生的關鍵因素。覆蓋律模型無法捕捉這種關鍵性。</p>
<p>既然覆蓋律模型有這些問題，哲學家當然試圖提出其他理解科學解釋的方式。其中一支文獻涉及因果性。同樣地，因為應該還有很多機會寫到這個主題，暫且不深入討論。不過，以上述兩個例子而言，訴諸因果性的方案確實避免了覆蓋律模型的問題。考慮旗杆問題。為什麼我們的直覺告訴我們給定普遍的律則，旗杆的高度解釋了影子的長度，而反之不然。這是因為旗杆的高度是影子長度為 <span class="math inline">\(20\)</span> 公尺的原因，而反之不然。通常我們認為因果性是不對稱的關係，因此它避免了覆蓋律模型的對稱性問題。同樣地，因果性也避免了無關緊要的解釋項問題。如果我們問醫生為什麼那個男人沒有懷孕，而醫生回答說，「因為他是男人。」這個解釋是好的，因為男人不會懷孕是因為他是男人。這個解釋包含了對於被解釋項的發生的關鍵因素。</p>
</section>
</section>
<section id="同學會" class="level2">
<h2 class="anchored" data-anchor-id="同學會">同學會</h2>
<p>說是同學會，只找了 10 個人，但說不是同學會，我們也見到高中班導了。</p>
<p>最近幾天一些以前的高中同學揪了一團週末在臺中聚聚。於是我週六早上八點半從臺北搭高鐵自由座到新烏日，然後搭火車到臺中車站。</p>
<p>早上聽了一會同學預約的旅客服務中心提供的車站附近的導覽，然後溜去吃宮原眼科，這是我第一次吃。午餐在豐樂公園附近吃了義大利麵，附近的迪卡儂晃晃，然後玩了<a href="https://www.facebook.com/lazertrekstaichung/?locale=zh_TW">鐳射🔫</a>。</p>
<p>晚餐時間進到文心秀泰裡閒晃，竟然遇到高中班導。我高中畢業以後就沒看過他，至今五年多，他感覺沒什麼變老，而且好像還稍微變瘦了。他跟他的太太和三個孩子剛吃完飯，準備離開。他也覺得很驚訝。我們一行人，他唸了其中三個人的名字，但他搭著我的肩說「啊想不起來你的名字了，你是那個轉班的。」<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> 然後大家合影留念。最後在公園玩了一會在迪卡儂買的海綿球，就像高中時代一樣，然後回家。</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>值得一寫但不值得單獨一篇的內容。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>這裡僅僅只是列出書上所提及的問題。事實上，此模型的問題還有更多。比如說，如果有人認同經濟學是一門科學（先不論他為何會如此覺得），那他應該也很難認同覆蓋律模型成功描繪了所有科學解釋的樣貌——絕大多數經濟解釋無法適配這樣的結構。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>他是我高一、二的班導，我高三轉讀社會組。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">This site is powered by <a href="https://quarto.org">Quarto</a></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.facebook.com/">
      <i class="bi bi-facebook" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>



</body></html>